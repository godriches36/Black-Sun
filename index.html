<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Neon Pong</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Setup */
        body {
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            font-family: 'Inter', monospace, sans-serif; /* Monospace for retro feel */
            color: #fff;
            padding: 1rem;
        }

        /* Canvas Container & Styling */
        #game-container {
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 4px solid #333333; /* Dark border for arcade cabinet feel */
            border-radius: 8px;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.2); /* Subtle glow effect */
        }

        #pong-canvas {
            display: block;
            background-color: #000000;
            border-radius: 4px;
            cursor: none; /* Hide mouse cursor inside the game */
        }

        /* Scoreboard & Instructions */
        #scoreboard {
            font-family: monospace;
            font-size: 1.5rem;
            color: #00ffff; /* Neon cyan */
            text-shadow: 0 0 5px #00ffff;
            padding: 0.5rem 0;
            text-align: center;
            user-select: none;
        }

        #instructions {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-top: 1rem;
            padding: 0 1rem;
            text-align: center;
        }

        /* Responsive Canvas Scaling */
        @media (max-width: 600px) {
            #game-container {
                max-width: 100%;
                border-width: 2px;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            }
            #scoreboard {
                font-size: 1.2rem;
            }
            #instructions {
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="scoreboard" class="text-xl">
        <span id="player-score">0</span> | <span id="computer-score">0</span>
    </div>
    <canvas id="pong-canvas"></canvas>
    <div id="instructions">
        **PC:** Move paddle with mouse/pointer vertically. | **Mobile:** Tap and drag to move paddle.
    </div>
</div>

<script>
    const canvas = document.getElementById('pong-canvas');
    const ctx = canvas.getContext('2d');
    const scorePlayerEl = document.getElementById('player-score');
    const scoreComputerEl = document.getElementById('computer-score');

    // Game Constants and Colors (Neon Theme)
    const PADDLE_WIDTH = 10;
    const PADDLE_HEIGHT = 100;
    const BALL_SIZE = 8;
    const PLAYER_COLOR = '#00ffff'; // Neon Cyan
    const COMPUTER_COLOR = '#ff00ff'; // Neon Magenta
    const BALL_COLOR = '#00ff00'; // Neon Green
    const NET_COLOR = '#0f4d4d'; // Darker Cyan for Net

    // Game State Variables
    let playerY, comY;
    let ballX, ballY;
    let ballSpeedX, ballSpeedY;
    let playerScore = 0;
    let computerScore = 0;

    // --- Utility Functions ---

    // Function to resize canvas for responsiveness
    function resizeCanvas() {
        const aspectRatio = 16 / 9; // Maintain 16:9 ratio
        const container = document.getElementById('game-container');
        const width = container.offsetWidth;
        
        // Ensure canvas width scales but is capped
        canvas.width = width;
        canvas.height = width / aspectRatio;

        // Reset positions after resize
        resetBall();
        playerY = canvas.height / 2 - PADDLE_HEIGHT / 2;
        comY = canvas.height / 2 - PADDLE_HEIGHT / 2;
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', () => {
        resizeCanvas();
        resetBall();
        gameLoop();
    });

    // Function to reset the ball to the center and randomize direction
    function resetBall() {
        ballX = canvas.width / 2;
        ballY = canvas.height / 2;

        // Randomize starting direction
        const dirX = Math.random() < 0.5 ? -1 : 1;
        const dirY = Math.random() * 2 - 1; // Between -1 and 1

        // Beginner-friendly slow initial speed
        ballSpeedX = dirX * 7;
        ballSpeedY = dirY * 4;
    }

    // Function to update the score display
    function updateScoreDisplay() {
        scorePlayerEl.textContent = playerScore;
        scoreComputerEl.textContent = computerScore;
    }

    // --- Drawing Functions ---

    function drawRect(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
        // Add a neon glow effect
        ctx.shadowColor = color;
        ctx.shadowBlur = 10;
        ctx.fillRect(x, y, w, h);
        ctx.shadowBlur = 0; // Reset blur
    }

    function drawCircle(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2, true);
        ctx.fill();
        // Add a neon glow effect
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;
        ctx.fill();
        ctx.shadowBlur = 0; // Reset blur
    }

    function drawNet() {
        for (let i = 0; i < canvas.height; i += 40) {
            drawRect(canvas.width / 2 - 1, i, 2, 20, NET_COLOR);
        }
    }

    function draw() {
        // Black Background
        drawRect(0, 0, canvas.width, canvas.height, '#000000');

        // Draw Net
        drawNet();

        // Draw Paddles
        drawRect(0, playerY, PADDLE_WIDTH, PADDLE_HEIGHT, PLAYER_COLOR);
        drawRect(canvas.width - PADDLE_WIDTH, comY, PADDLE_WIDTH, PADDLE_HEIGHT, COMPUTER_COLOR);

        // Draw Ball
        drawCircle(ballX, ballY, BALL_SIZE, BALL_COLOR);
    }

    // --- Game Logic ---

    // AI Movement (Simple and slow for beginners)
    function computerMovement() {
        // Target the center of the paddle to slightly overshoot the ball's Y position
        const paddleCenter = comY + PADDLE_HEIGHT / 2;
        const speed = 4.5; // Very slow speed, making it easy to beat

        if (paddleCenter < ballY - 15) {
            comY += speed;
        } else if (paddleCenter > ballY + 15) {
            comY -= speed;
        }

        // Clamp AI paddle to boundaries
        if (comY < 0) comY = 0;
        if (comY > canvas.height - PADDLE_HEIGHT) comY = canvas.height - PADDLE_HEIGHT;
    }

    function update() {
        // 1. Update Ball Position
        ballX += ballSpeedX;
        ballY += ballSpeedY;

        // 2. Computer AI Movement
        computerMovement();

        // 3. Wall Collision (Top/Bottom)
        if (ballY < BALL_SIZE || ballY > canvas.height - BALL_SIZE) {
            ballSpeedY = -ballSpeedY; // Reverse vertical direction
        }

        // 4. Scoring (Left/Right)
        if (ballX < 0) {
            computerScore++;
            updateScoreDisplay();
            resetBall();
        }
        if (ballX > canvas.width) {
            playerScore++;
            updateScoreDisplay();
            resetBall();
        }

        // 5. Paddle Collision
        let paddleY;
        let isPlayerPaddle = false;

        if (ballSpeedX < 0) { // Moving left (Player side)
            if (ballX < PADDLE_WIDTH + BALL_SIZE && ballY > playerY && ballY < playerY + PADDLE_HEIGHT) {
                isPlayerPaddle = true;
                paddleY = playerY;
                ballSpeedX = -ballSpeedX;
            }
        } else { // Moving right (Computer side)
            if (ballX > canvas.width - PADDLE_WIDTH - BALL_SIZE && ballY > comY && ballY < comY + PADDLE_HEIGHT) {
                isPlayerPaddle = false;
                paddleY = comY;
                ballSpeedX = -ballSpeedX;
            }
        }

        // 6. Adjust Ball Angle based on hit location and increase speed slightly
        if (ballSpeedX < 0 && isPlayerPaddle) { // Player hit logic
            let deltaY = ballY - (playerY + PADDLE_HEIGHT / 2); // Distance from paddle center
            ballSpeedY = deltaY * 0.3; // Angle based on hit location
            ballSpeedX = Math.min(ballSpeedX - 0.5, -15); // Increase speed cap at -15
        } else if (ballSpeedX > 0 && !isPlayerPaddle) { // Computer hit logic
            let deltaY = ballY - (comY + PADDLE_HEIGHT / 2);
            ballSpeedY = deltaY * 0.3;
            ballSpeedX = Math.max(ballSpeedX + 0.5, 15); // Increase speed cap at 15
        }
    }

    // --- Input Handling ---

    function handleInput(clientY, isTouch = false) {
        const rect = canvas.getBoundingClientRect();
        // Calculate the relative Y position of the pointer within the canvas
        const scaleY = canvas.height / rect.height;
        let newPaddleY = (clientY - rect.top) * scaleY - PADDLE_HEIGHT / 2;

        // Clamp the paddle movement to the top and bottom of the canvas
        if (newPaddleY < 0) {
            newPaddleY = 0;
        } else if (newPaddleY > canvas.height - PADDLE_HEIGHT) {
            newPaddleY = canvas.height - PADDLE_HEIGHT;
        }

        playerY = newPaddleY;
    }

    // Mouse/Pointer Listener
    canvas.addEventListener('mousemove', (evt) => {
        handleInput(evt.clientY);
    });

    // Touch Listeners for Mobile
    canvas.addEventListener('touchmove', (evt) => {
        evt.preventDefault(); // Prevent scrolling on touch
        if (evt.touches.length > 0) {
            handleInput(evt.touches[0].clientY, true);
        }
    }, { passive: false });

    // --- Game Loop ---

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop); // Loop the game
    }
</script>
</body>
</html>

